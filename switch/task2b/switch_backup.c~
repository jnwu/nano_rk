/*******************************************************
 *
 *  Switch Routines for EECE 494, Assignment 2.
 *
 *  Created by _________, University of British Columbia
 *
 *  This is where you will put your routines to implement
 *  the switch routines.  You should use the headers as
 *  supplied.  All your code for Assignment 2 will go in this
 *  file (and possibly in switch.h)
 *
 ******************************************************/

#include "defs.h"

packet_t *queue[4];


//@TODO: define global data structure for sending / receiving requests

//@TODO: define VOQ data structure

//@TODO: add function for an input port to send request to an output port

//@TODO: add function for an input port to receive response to the reuqest from output port

//@TODO: add function for an output port to send response for the input port's request

//@TODO: add function for an output port to receive request message from a input port



void *switch_thread_routine(void *arg)
{
   /* Add your code here */
	int i;
	int to_port;
	int from_port;
	int cnt = 0;
	int a;
	int result;
	BOOL in_progress = TRUE;
	packet_t *packet;   /* Temporary packet that will hold the packet between in port and out port */

	while(1) {
		for(i=0 ; i<4 ; i++) {

			/* Cycle through the ports and check if any in ports have a packet waiting to be switched */

			//@TODO: change the content below to put packets into VOQ
			if(in_port[i].flag) { //if flag is set
					port_lock(&(in_port[i])); //lock in_port

					/* New packet to be passed to the out port */

					packet = (packet_t *) malloc(sizeof(packet_t)); //locate memory for tmp packet

					packet_copy(&(in_port[i].packet),
               					packet); //copy incoming packet to tmp packet holder
				    
					result = cam_lookup_address(&(packet->address)); //get the destination port

      				from_port = packet->payload & 3; //get the source port
      				to_port = (packet->payload / 4) & 3; //get the port to send the packet to

      				if (from_port != i) { //if the source port does not match, report error

         				printf("Error: received packet from port %d when it should have come on port %d\n",
                     			from_port, i);
         				
         			} else { // if no error

      					switch_enqueue(result, packet); //add the packet to the destination address's queue

      				}

  					in_port[i].flag = FALSE; //clear the in_port's busy flag
					port_unlock(&(in_port[i])); // free the in_port
			}
		}


		for(i=0 ; i<4 ; i++) {
			if(queue[i] && !(out_port[i].flag)) { //if the queue is not empty and the out_port is not busy

					port_lock(&(out_port[i])); //get a hold of the out_port

					/* New packet to be passed to the out port */

					packet = switch_dequeue(i); //obtain packet from the queue

					to_port = (packet->payload / 4) & 3; //calculate which port the packet is destined to

      				if (to_port != i) { //if the destined port is not the current port, report error

         				printf("Error: received packet to port %d when it should have come on port %d\n",
                     			to_port, i);
         			}

					packet_copy(packet,
               					&(out_port[i].packet)); // if not error, copy the packet to out_port to be sent

					out_port[i].flag = TRUE; //flag outport to be busy

					port_unlock(&(out_port[i])); //send packet
			}
		}
	}
}


void switch_init()
{
   /* Add your code here.  At the very least, you probably
      want to include a call to cam_init() */
	cam_init();
}

void switch_add_entry(ip_address_t *address,
                      int port)
{
   /* Add your code here.  It might be as simple as adding
      a call to cam_add_entry() */
	cam_add_entry(address, port);
}

void switch_free()
{
   /* add your code (if any) here */
	cam_free();
}

void switch_enqueue(int i, packet_t *packet) 
{
	packet_t *tmp = queue[i]; //obtain a copy of the queue for packets going to port i
	packet->next = NULL; //make the passed in packet's next packet to be null

	if(!queue[i]) {
		queue[i] = packet; //if the current queue is empty, then add packet as the only element of the queue
		return;		
	}

	while(tmp) //try to reach the last element of the linked list
	{
		if(!(tmp->next))
			break;
		tmp=tmp->next;
	}

	tmp->next = packet; //insert packet to be the end of the queue
}


packet_t* switch_dequeue (int i)
{
	packet_t *packet = NULL; //create a packet place holder

	if(queue[i]) { //if queue is not empty
		packet = queue[i];  //obtain the head of the queue
		queue[i] = queue[i]->next; //the second element is the new head of the queue
	}

	return packet; //return the obtained packet
}
