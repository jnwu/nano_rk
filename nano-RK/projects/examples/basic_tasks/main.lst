   1               		.file	"main.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 137               		.data
 138               	.LC0:
 139 0000 5461 736B 		.string	"Task3 PID=%d\r\n"
 139      3320 5049 
 139      443D 2564 
 139      0D0A 00
 140               	.LC1:
 141 000f 5461 736B 		.string	"Task3 cnt=%d\r\n"
 141      3320 636E 
 141      743D 2564 
 141      0D0A 00
 142               		.text
 144               	.global	Task3
 146               	Task3:
 147               		.stabd	46,0,0
   1:main.c        **** /******************************************************************************
   2:main.c        **** *  Nano-RK, a real-time operating system for sensor networks.
   3:main.c        **** *  Copyright (C) 2007, Real-Time and Multimedia Lab, Carnegie Mellon University
   4:main.c        **** *  All rights reserved.
   5:main.c        **** *
   6:main.c        **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:main.c        **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:main.c        **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:main.c        **** *
  10:main.c        **** *  This program is free software: you can redistribute it and/or modify
  11:main.c        **** *  it under the terms of the GNU General Public License as published by
  12:main.c        **** *  the Free Software Foundation, version 2.0 of the License.
  13:main.c        **** *
  14:main.c        **** *  This program is distributed in the hope that it will be useful,
  15:main.c        **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:main.c        **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:main.c        **** *  GNU General Public License for more details.
  18:main.c        **** *
  19:main.c        **** *  You should have received a copy of the GNU General Public License
  20:main.c        **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:main.c        **** *
  22:main.c        **** *  Contributing Authors (specific to this file):
  23:main.c        **** *  Zane Starr
  24:main.c        **** *******************************************************************************/
  25:main.c        **** 
  26:main.c        **** 
  27:main.c        **** #include <nrk.h>
  28:main.c        **** #include <include.h>
  29:main.c        **** #include <ulib.h>
  30:main.c        **** #include <stdio.h>
  31:main.c        **** #include <avr/sleep.h>
  32:main.c        **** #include <hal.h>
  33:main.c        **** #include <nrk_error.h>
  34:main.c        **** #include <nrk_events.h>
  35:main.c        **** #include <nrk_timer.h>
  36:main.c        **** 
  37:main.c        **** 
  38:main.c        **** NRK_STK Stack1[NRK_APP_STACKSIZE];
  39:main.c        **** nrk_task_type TaskOne;
  40:main.c        **** void Task1(void);
  41:main.c        **** 
  42:main.c        **** NRK_STK Stack2[NRK_APP_STACKSIZE];
  43:main.c        **** nrk_task_type TaskTwo;
  44:main.c        **** void Task2 (void);
  45:main.c        **** 
  46:main.c        **** NRK_STK Stack3[NRK_APP_STACKSIZE];
  47:main.c        **** nrk_task_type TaskThree;
  48:main.c        **** void Task3 (void);
  49:main.c        **** 
  50:main.c        **** void nrk_create_taskset();
  51:main.c        **** 
  52:main.c        **** nrk_sem_t *my_semaphore;
  53:main.c        **** 
  54:main.c        **** int
  55:main.c        **** main ()
  56:main.c        **** {
  57:main.c        ****   uint8_t t;
  58:main.c        ****   nrk_setup_ports();
  59:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
  60:main.c        **** 
  61:main.c        ****   printf( "Starting up...\r\n" );
  62:main.c        **** 
  63:main.c        ****   nrk_init();
  64:main.c        **** 
  65:main.c        ****   nrk_led_clr(ORANGE_LED);
  66:main.c        ****   nrk_led_clr(BLUE_LED);
  67:main.c        ****   nrk_led_set(GREEN_LED);
  68:main.c        ****   nrk_led_clr(RED_LED);
  69:main.c        ****  
  70:main.c        ****   nrk_time_set(0,0);
  71:main.c        ****   nrk_create_taskset ();
  72:main.c        **** 
  73:main.c        ****   my_semaphore = nrk_sem_create(1,2);
  74:main.c        ****   if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
  75:main.c        ****   nrk_start();
  76:main.c        ****   
  77:main.c        ****   return 0;
  78:main.c        **** }
  79:main.c        **** 
  80:main.c        **** 
  81:main.c        **** void Task1()
  82:main.c        **** {
  83:main.c        **** uint16_t cnt;
  84:main.c        **** int8_t v;
  85:main.c        **** 
  86:main.c        **** printf( "My node's address is %d\r\n",NODE_ADDR );
  87:main.c        **** 
  88:main.c        ****   printf( "Task1 PID=%d\r\n",nrk_get_pid());
  89:main.c        ****   cnt=0;
  90:main.c        ****   while(1) {
  91:main.c        **** 	nrk_led_toggle(ORANGE_LED);
  92:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
  93:main.c        **** 	nrk_wait_until_next_period();
  94:main.c        **** 	nrk_kprintf( PSTR("Task1 accessing semaphore\r\n"));
  95:main.c        **** 	v = nrk_sem_pend(my_semaphore);
  96:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
  97:main.c        **** 	nrk_kprintf( PSTR("Task1 holding semaphore\r\n"));
  98:main.c        **** 	// wait some time inside semaphore to show the effect
  99:main.c        **** 	nrk_wait_until_next_period();
 100:main.c        **** 	v = nrk_sem_post(my_semaphore);
 101:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 102:main.c        **** 	nrk_kprintf( PSTR("Task1 released semaphore\r\n"));
 103:main.c        **** 	nrk_wait_until_next_period();
 104:main.c        **** 	cnt++;
 105:main.c        **** 	}
 106:main.c        **** }
 107:main.c        **** 
 108:main.c        **** void Task2()
 109:main.c        **** {
 110:main.c        ****   uint8_t cnt;
 111:main.c        ****   int8_t v;
 112:main.c        **** 
 113:main.c        ****   printf( "Task2 PID=%d\r\n",nrk_get_pid());
 114:main.c        ****   cnt=0;
 115:main.c        ****   while(1) {
 116:main.c        ****         nrk_led_toggle(ORANGE_LED);
 117:main.c        ****         printf( "Task2 cnt=%d\r\n",cnt );
 118:main.c        ****         nrk_kprintf( PSTR("Task2 accessing semaphore\r\n"));
 119:main.c        ****         v = nrk_sem_pend(my_semaphore);
 120:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 121:main.c        ****         nrk_kprintf( PSTR("Task2 holding semaphore\r\n"));
 122:main.c        **** 	// wait some time inside semaphore to show the effect
 123:main.c        ****         nrk_spin_wait_us(1000000);
 124:main.c        ****         v = nrk_sem_post(my_semaphore);
 125:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 126:main.c        ****         nrk_kprintf( PSTR("Task2 released semaphore\r\n"));
 127:main.c        ****         nrk_wait_until_next_period();
 128:main.c        ****         cnt++;
 129:main.c        ****         }
 130:main.c        **** }
 131:main.c        **** 
 132:main.c        **** void Task3()
 133:main.c        **** {
 149               	.LM0:
 150               	.LFBB1:
 151 0000 0F93      		push r16
 152 0002 1F93      		push r17
 153 0004 CF93      		push r28
 154 0006 DF93      		push r29
 155               	/* prologue: function */
 156               	/* frame size = 0 */
 157               	/* stack size = 4 */
 158               	.L__stack_usage = 4
 134:main.c        **** uint16_t cnt;
 135:main.c        **** uint16_t i;
 136:main.c        ****   printf( "Task3 PID=%d\r\n",nrk_get_pid());
 160               	.LM1:
 161 0008 0E94 0000 		call nrk_get_pid
 162 000c 00D0      		rcall .
 163 000e 00D0      		rcall .
 164 0010 EDB7      		in r30,__SP_L__
 165 0012 FEB7      		in r31,__SP_H__
 166 0014 3196      		adiw r30,1
 167 0016 20E0      		ldi r18,lo8(.LC0)
 168 0018 30E0      		ldi r19,hi8(.LC0)
 169 001a ADB7      		in r26,__SP_L__
 170 001c BEB7      		in r27,__SP_H__
 171 001e 1296      		adiw r26,1+1
 172 0020 3C93      		st X,r19
 173 0022 2E93      		st -X,r18
 174 0024 1197      		sbiw r26,1
 175 0026 8283      		std Z+2,r24
 176 0028 1382      		std Z+3,__zero_reg__
 177 002a 0E94 0000 		call printf
 178 002e 0F90      		pop __tmp_reg__
 179 0030 0F90      		pop __tmp_reg__
 180 0032 0F90      		pop __tmp_reg__
 181 0034 0F90      		pop __tmp_reg__
 137:main.c        ****   cnt=0;
 183               	.LM2:
 184 0036 C0E0      		ldi r28,lo8(0)
 185 0038 D0E0      		ldi r29,hi8(0)
 138:main.c        ****   while(1) {
 139:main.c        **** 	printf( "Task3 cnt=%d\r\n",cnt );
 187               	.LM3:
 188 003a 00E0      		ldi r16,lo8(.LC1)
 189 003c 10E0      		ldi r17,hi8(.LC1)
 190               	.L2:
 192               	.LM4:
 193 003e 00D0      		rcall .
 194 0040 00D0      		rcall .
 195 0042 EDB7      		in r30,__SP_L__
 196 0044 FEB7      		in r31,__SP_H__
 197 0046 1283      		std Z+2,r17
 198 0048 0183      		std Z+1,r16
 199 004a D483      		std Z+4,r29
 200 004c C383      		std Z+3,r28
 201 004e 0E94 0000 		call printf
 140:main.c        **** 	nrk_spin_wait_us(100000);
 203               	.LM5:
 204 0052 0F90      		pop __tmp_reg__
 205 0054 0F90      		pop __tmp_reg__
 206 0056 0F90      		pop __tmp_reg__
 207 0058 0F90      		pop __tmp_reg__
 208 005a 80EA      		ldi r24,lo8(-31072)
 209 005c 96E8      		ldi r25,hi8(-31072)
 210 005e 0E94 0000 		call nrk_spin_wait_us
 141:main.c        **** 	nrk_wait_until_next_period();
 212               	.LM6:
 213 0062 0E94 0000 		call nrk_wait_until_next_period
 142:main.c        **** 	cnt++;
 215               	.LM7:
 216 0066 2196      		adiw r28,1
 217 0068 00C0      		rjmp .L2
 222               	.Lscope1:
 224               		.stabd	78,0,0
 225               		.data
 226               	.LC2:
 227 001e 5461 736B 		.string	"Task2 PID=%d\r\n"
 227      3220 5049 
 227      443D 2564 
 227      0D0A 00
 228               	.LC3:
 229 002d 5461 736B 		.string	"Task2 cnt=%d\r\n"
 229      3220 636E 
 229      743D 2564 
 229      0D0A 00
 230               		.text
 232               	.global	Task2
 234               	Task2:
 235               		.stabd	46,0,0
 109:main.c        **** {
 237               	.LM8:
 238               	.LFBB2:
 239 006a 1F93      		push r17
 240 006c CF93      		push r28
 241 006e DF93      		push r29
 242               	/* prologue: function */
 243               	/* frame size = 0 */
 244               	/* stack size = 3 */
 245               	.L__stack_usage = 3
 113:main.c        ****   printf( "Task2 PID=%d\r\n",nrk_get_pid());
 247               	.LM9:
 248 0070 0E94 0000 		call nrk_get_pid
 249 0074 00D0      		rcall .
 250 0076 00D0      		rcall .
 251 0078 EDB7      		in r30,__SP_L__
 252 007a FEB7      		in r31,__SP_H__
 253 007c 3196      		adiw r30,1
 254 007e 20E0      		ldi r18,lo8(.LC2)
 255 0080 30E0      		ldi r19,hi8(.LC2)
 256 0082 ADB7      		in r26,__SP_L__
 257 0084 BEB7      		in r27,__SP_H__
 258 0086 1296      		adiw r26,1+1
 259 0088 3C93      		st X,r19
 260 008a 2E93      		st -X,r18
 261 008c 1197      		sbiw r26,1
 262 008e 8283      		std Z+2,r24
 263 0090 1382      		std Z+3,__zero_reg__
 264 0092 0E94 0000 		call printf
 265 0096 0F90      		pop __tmp_reg__
 266 0098 0F90      		pop __tmp_reg__
 267 009a 0F90      		pop __tmp_reg__
 268 009c 0F90      		pop __tmp_reg__
 114:main.c        ****   cnt=0;
 270               	.LM10:
 271 009e 10E0      		ldi r17,lo8(0)
 117:main.c        ****         printf( "Task2 cnt=%d\r\n",cnt );
 273               	.LM11:
 274 00a0 C0E0      		ldi r28,lo8(.LC3)
 275 00a2 D0E0      		ldi r29,hi8(.LC3)
 276               	.L6:
 116:main.c        ****         nrk_led_toggle(ORANGE_LED);
 278               	.LM12:
 279 00a4 80E0      		ldi r24,lo8(0)
 280 00a6 90E0      		ldi r25,hi8(0)
 281 00a8 0E94 0000 		call nrk_led_toggle
 117:main.c        ****         printf( "Task2 cnt=%d\r\n",cnt );
 283               	.LM13:
 284 00ac 00D0      		rcall .
 285 00ae 00D0      		rcall .
 286 00b0 EDB7      		in r30,__SP_L__
 287 00b2 FEB7      		in r31,__SP_H__
 288 00b4 3196      		adiw r30,1
 289 00b6 ADB7      		in r26,__SP_L__
 290 00b8 BEB7      		in r27,__SP_H__
 291 00ba 1296      		adiw r26,1+1
 292 00bc DC93      		st X,r29
 293 00be CE93      		st -X,r28
 294 00c0 1197      		sbiw r26,1
 295 00c2 1283      		std Z+2,r17
 296 00c4 1382      		std Z+3,__zero_reg__
 297 00c6 0E94 0000 		call printf
 118:main.c        ****         nrk_kprintf( PSTR("Task2 accessing semaphore\r\n"));
 299               	.LM14:
 300 00ca 0F90      		pop __tmp_reg__
 301 00cc 0F90      		pop __tmp_reg__
 302 00ce 0F90      		pop __tmp_reg__
 303 00d0 0F90      		pop __tmp_reg__
 304 00d2 80E0      		ldi r24,lo8(__c.2146)
 305 00d4 90E0      		ldi r25,hi8(__c.2146)
 306 00d6 0E94 0000 		call nrk_kprintf
 119:main.c        ****         v = nrk_sem_pend(my_semaphore);
 308               	.LM15:
 309 00da 8091 0000 		lds r24,my_semaphore
 310 00de 9091 0000 		lds r25,my_semaphore+1
 311 00e2 0E94 0000 		call nrk_sem_pend
 120:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 313               	.LM16:
 314 00e6 8F3F      		cpi r24,lo8(-1)
 315 00e8 01F4      		brne .L4
 120:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error pend\r\n"));
 317               	.LM17:
 318 00ea 80E0      		ldi r24,lo8(__c.2148)
 319 00ec 90E0      		ldi r25,hi8(__c.2148)
 320 00ee 0E94 0000 		call nrk_kprintf
 321               	.L4:
 121:main.c        ****         nrk_kprintf( PSTR("Task2 holding semaphore\r\n"));
 323               	.LM18:
 324 00f2 80E0      		ldi r24,lo8(__c.2150)
 325 00f4 90E0      		ldi r25,hi8(__c.2150)
 326 00f6 0E94 0000 		call nrk_kprintf
 123:main.c        ****         nrk_spin_wait_us(1000000);
 328               	.LM19:
 329 00fa 80E4      		ldi r24,lo8(16960)
 330 00fc 92E4      		ldi r25,hi8(16960)
 331 00fe 0E94 0000 		call nrk_spin_wait_us
 124:main.c        ****         v = nrk_sem_post(my_semaphore);
 333               	.LM20:
 334 0102 8091 0000 		lds r24,my_semaphore
 335 0106 9091 0000 		lds r25,my_semaphore+1
 336 010a 0E94 0000 		call nrk_sem_post
 125:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 338               	.LM21:
 339 010e 8F3F      		cpi r24,lo8(-1)
 340 0110 01F4      		brne .L5
 125:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T2 error post\r\n"));
 342               	.LM22:
 343 0112 80E0      		ldi r24,lo8(__c.2152)
 344 0114 90E0      		ldi r25,hi8(__c.2152)
 345 0116 0E94 0000 		call nrk_kprintf
 346               	.L5:
 126:main.c        ****         nrk_kprintf( PSTR("Task2 released semaphore\r\n"));
 348               	.LM23:
 349 011a 80E0      		ldi r24,lo8(__c.2154)
 350 011c 90E0      		ldi r25,hi8(__c.2154)
 351 011e 0E94 0000 		call nrk_kprintf
 127:main.c        ****         nrk_wait_until_next_period();
 353               	.LM24:
 354 0122 0E94 0000 		call nrk_wait_until_next_period
 128:main.c        ****         cnt++;
 356               	.LM25:
 357 0126 1F5F      		subi r17,lo8(-(1))
 129:main.c        ****         }
 359               	.LM26:
 360 0128 00C0      		rjmp .L6
 365               	.Lscope2:
 367               		.stabd	78,0,0
 368               		.data
 369               	.LC4:
 370 003c 4D79 206E 		.string	"My node's address is %d\r\n"
 370      6F64 6527 
 370      7320 6164 
 370      6472 6573 
 370      7320 6973 
 371               	.LC5:
 372 0056 5461 736B 		.string	"Task1 PID=%d\r\n"
 372      3120 5049 
 372      443D 2564 
 372      0D0A 00
 373               	.LC6:
 374 0065 5461 736B 		.string	"Task1 cnt=%d\r\n"
 374      3120 636E 
 374      743D 2564 
 374      0D0A 00
 375               		.text
 377               	.global	Task1
 379               	Task1:
 380               		.stabd	46,0,0
  82:main.c        **** {
 382               	.LM27:
 383               	.LFBB3:
 384 012a 0F93      		push r16
 385 012c 1F93      		push r17
 386 012e CF93      		push r28
 387 0130 DF93      		push r29
 388               	/* prologue: function */
 389               	/* frame size = 0 */
 390               	/* stack size = 4 */
 391               	.L__stack_usage = 4
  86:main.c        **** printf( "My node's address is %d\r\n",NODE_ADDR );
 393               	.LM28:
 394 0132 00D0      		rcall .
 395 0134 00D0      		rcall .
 396 0136 80E0      		ldi r24,lo8(.LC4)
 397 0138 90E0      		ldi r25,hi8(.LC4)
 398 013a ADB7      		in r26,__SP_L__
 399 013c BEB7      		in r27,__SP_H__
 400 013e 1296      		adiw r26,1+1
 401 0140 9C93      		st X,r25
 402 0142 8E93      		st -X,r24
 403 0144 1197      		sbiw r26,1
 404 0146 1496      		adiw r26,3+1
 405 0148 1C92      		st X,__zero_reg__
 406 014a 1E92      		st -X,__zero_reg__
 407 014c 1397      		sbiw r26,3
 408 014e 0E94 0000 		call printf
  88:main.c        ****   printf( "Task1 PID=%d\r\n",nrk_get_pid());
 410               	.LM29:
 411 0152 0F90      		pop __tmp_reg__
 412 0154 0F90      		pop __tmp_reg__
 413 0156 0F90      		pop __tmp_reg__
 414 0158 0F90      		pop __tmp_reg__
 415 015a 0E94 0000 		call nrk_get_pid
 416 015e 00D0      		rcall .
 417 0160 00D0      		rcall .
 418 0162 EDB7      		in r30,__SP_L__
 419 0164 FEB7      		in r31,__SP_H__
 420 0166 3196      		adiw r30,1
 421 0168 20E0      		ldi r18,lo8(.LC5)
 422 016a 30E0      		ldi r19,hi8(.LC5)
 423 016c ADB7      		in r26,__SP_L__
 424 016e BEB7      		in r27,__SP_H__
 425 0170 1296      		adiw r26,1+1
 426 0172 3C93      		st X,r19
 427 0174 2E93      		st -X,r18
 428 0176 1197      		sbiw r26,1
 429 0178 8283      		std Z+2,r24
 430 017a 1382      		std Z+3,__zero_reg__
 431 017c 0E94 0000 		call printf
 432 0180 0F90      		pop __tmp_reg__
 433 0182 0F90      		pop __tmp_reg__
 434 0184 0F90      		pop __tmp_reg__
 435 0186 0F90      		pop __tmp_reg__
  89:main.c        ****   cnt=0;
 437               	.LM30:
 438 0188 C0E0      		ldi r28,lo8(0)
 439 018a D0E0      		ldi r29,hi8(0)
  92:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 441               	.LM31:
 442 018c 00E0      		ldi r16,lo8(.LC6)
 443 018e 10E0      		ldi r17,hi8(.LC6)
 444               	.L10:
  91:main.c        **** 	nrk_led_toggle(ORANGE_LED);
 446               	.LM32:
 447 0190 80E0      		ldi r24,lo8(0)
 448 0192 90E0      		ldi r25,hi8(0)
 449 0194 0E94 0000 		call nrk_led_toggle
  92:main.c        **** 	printf( "Task1 cnt=%d\r\n",cnt );
 451               	.LM33:
 452 0198 00D0      		rcall .
 453 019a 00D0      		rcall .
 454 019c EDB7      		in r30,__SP_L__
 455 019e FEB7      		in r31,__SP_H__
 456 01a0 1283      		std Z+2,r17
 457 01a2 0183      		std Z+1,r16
 458 01a4 D483      		std Z+4,r29
 459 01a6 C383      		std Z+3,r28
 460 01a8 0E94 0000 		call printf
  93:main.c        **** 	nrk_wait_until_next_period();
 462               	.LM34:
 463 01ac 0F90      		pop __tmp_reg__
 464 01ae 0F90      		pop __tmp_reg__
 465 01b0 0F90      		pop __tmp_reg__
 466 01b2 0F90      		pop __tmp_reg__
 467 01b4 0E94 0000 		call nrk_wait_until_next_period
  94:main.c        **** 	nrk_kprintf( PSTR("Task1 accessing semaphore\r\n"));
 469               	.LM35:
 470 01b8 80E0      		ldi r24,lo8(__c.2131)
 471 01ba 90E0      		ldi r25,hi8(__c.2131)
 472 01bc 0E94 0000 		call nrk_kprintf
  95:main.c        **** 	v = nrk_sem_pend(my_semaphore);
 474               	.LM36:
 475 01c0 8091 0000 		lds r24,my_semaphore
 476 01c4 9091 0000 		lds r25,my_semaphore+1
 477 01c8 0E94 0000 		call nrk_sem_pend
  96:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
 479               	.LM37:
 480 01cc 8F3F      		cpi r24,lo8(-1)
 481 01ce 01F4      		brne .L8
  96:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error pend\r\n"));
 483               	.LM38:
 484 01d0 80E0      		ldi r24,lo8(__c.2133)
 485 01d2 90E0      		ldi r25,hi8(__c.2133)
 486 01d4 0E94 0000 		call nrk_kprintf
 487               	.L8:
  97:main.c        **** 	nrk_kprintf( PSTR("Task1 holding semaphore\r\n"));
 489               	.LM39:
 490 01d8 80E0      		ldi r24,lo8(__c.2135)
 491 01da 90E0      		ldi r25,hi8(__c.2135)
 492 01dc 0E94 0000 		call nrk_kprintf
  99:main.c        **** 	nrk_wait_until_next_period();
 494               	.LM40:
 495 01e0 0E94 0000 		call nrk_wait_until_next_period
 100:main.c        **** 	v = nrk_sem_post(my_semaphore);
 497               	.LM41:
 498 01e4 8091 0000 		lds r24,my_semaphore
 499 01e8 9091 0000 		lds r25,my_semaphore+1
 500 01ec 0E94 0000 		call nrk_sem_post
 101:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 502               	.LM42:
 503 01f0 8F3F      		cpi r24,lo8(-1)
 504 01f2 01F4      		brne .L9
 101:main.c        **** 	if(v==NRK_ERROR) nrk_kprintf( PSTR("T1 error post\r\n"));
 506               	.LM43:
 507 01f4 80E0      		ldi r24,lo8(__c.2137)
 508 01f6 90E0      		ldi r25,hi8(__c.2137)
 509 01f8 0E94 0000 		call nrk_kprintf
 510               	.L9:
 102:main.c        **** 	nrk_kprintf( PSTR("Task1 released semaphore\r\n"));
 512               	.LM44:
 513 01fc 80E0      		ldi r24,lo8(__c.2139)
 514 01fe 90E0      		ldi r25,hi8(__c.2139)
 515 0200 0E94 0000 		call nrk_kprintf
 103:main.c        **** 	nrk_wait_until_next_period();
 517               	.LM45:
 518 0204 0E94 0000 		call nrk_wait_until_next_period
 104:main.c        **** 	cnt++;
 520               	.LM46:
 521 0208 2196      		adiw r28,1
 105:main.c        **** 	}
 523               	.LM47:
 524 020a 00C0      		rjmp .L10
 529               	.Lscope3:
 531               		.stabd	78,0,0
 533               	.global	nrk_create_taskset
 535               	nrk_create_taskset:
 536               		.stabd	46,0,0
 143:main.c        **** 	}
 144:main.c        **** }
 145:main.c        **** 
 146:main.c        **** void
 147:main.c        **** nrk_create_taskset()
 148:main.c        **** {
 538               	.LM48:
 539               	.LFBB4:
 540 020c DF92      		push r13
 541 020e EF92      		push r14
 542 0210 FF92      		push r15
 543 0212 0F93      		push r16
 544 0214 1F93      		push r17
 545               	/* prologue: function */
 546               	/* frame size = 0 */
 547               	/* stack size = 5 */
 548               	.L__stack_usage = 5
 149:main.c        ****   uint8_t i;
 150:main.c        **** 
 151:main.c        ****   TaskOne.task = Task1;
 550               	.LM49:
 551 0216 80E0      		ldi r24,lo8(gs(Task1))
 552 0218 90E0      		ldi r25,hi8(gs(Task1))
 553 021a 9093 0000 		sts TaskOne+5+1,r25
 554 021e 8093 0000 		sts TaskOne+5,r24
 152:main.c        ****   TaskOne.Ptos = (void *) &Stack1[NRK_APP_STACKSIZE];
 556               	.LM50:
 557 0222 80E0      		ldi r24,lo8(Stack1+128)
 558 0224 90E0      		ldi r25,hi8(Stack1+128)
 559 0226 9093 0000 		sts TaskOne+1+1,r25
 560 022a 8093 0000 		sts TaskOne+1,r24
 153:main.c        ****   TaskOne.Pbos = (void *) &Stack1[0];
 562               	.LM51:
 563 022e 80E0      		ldi r24,lo8(Stack1)
 564 0230 90E0      		ldi r25,hi8(Stack1)
 565 0232 9093 0000 		sts TaskOne+3+1,r25
 566 0236 8093 0000 		sts TaskOne+3,r24
 154:main.c        ****   TaskOne.prio = 2;
 568               	.LM52:
 569 023a 82E0      		ldi r24,lo8(2)
 570 023c 8093 0000 		sts TaskOne+8,r24
 155:main.c        ****   TaskOne.FirstActivation = TRUE;
 572               	.LM53:
 573 0240 DD24      		clr r13
 574 0242 D394      		inc r13
 575 0244 D092 0000 		sts TaskOne+7,r13
 156:main.c        ****   TaskOne.Type = BASIC_TASK;
 577               	.LM54:
 578 0248 D092 0000 		sts TaskOne+9,r13
 157:main.c        ****   TaskOne.SchType = PREEMPTIVE;
 580               	.LM55:
 581 024c D092 0000 		sts TaskOne+10,r13
 158:main.c        ****   TaskOne.period.secs = 0;
 583               	.LM56:
 584 0250 1092 0000 		sts TaskOne+11,__zero_reg__
 585 0254 1092 0000 		sts TaskOne+11+1,__zero_reg__
 586 0258 1092 0000 		sts TaskOne+11+2,__zero_reg__
 587 025c 1092 0000 		sts TaskOne+11+3,__zero_reg__
 159:main.c        ****   TaskOne.period.nano_secs = 250*NANOS_PER_MS;
 589               	.LM57:
 590 0260 80E8      		ldi r24,lo8(250000000)
 591 0262 92EB      		ldi r25,hi8(250000000)
 592 0264 A6EE      		ldi r26,hlo8(250000000)
 593 0266 BEE0      		ldi r27,hhi8(250000000)
 594 0268 8093 0000 		sts TaskOne+15,r24
 595 026c 9093 0000 		sts TaskOne+15+1,r25
 596 0270 A093 0000 		sts TaskOne+15+2,r26
 597 0274 B093 0000 		sts TaskOne+15+3,r27
 160:main.c        ****   TaskOne.cpu_reserve.secs = 0;
 599               	.LM58:
 600 0278 1092 0000 		sts TaskOne+19,__zero_reg__
 601 027c 1092 0000 		sts TaskOne+19+1,__zero_reg__
 602 0280 1092 0000 		sts TaskOne+19+2,__zero_reg__
 603 0284 1092 0000 		sts TaskOne+19+3,__zero_reg__
 161:main.c        ****   TaskOne.cpu_reserve.nano_secs =  50*NANOS_PER_MS;
 605               	.LM59:
 606 0288 80E8      		ldi r24,lo8(50000000)
 607 028a 90EF      		ldi r25,hi8(50000000)
 608 028c AAEF      		ldi r26,hlo8(50000000)
 609 028e B2E0      		ldi r27,hhi8(50000000)
 610 0290 8093 0000 		sts TaskOne+23,r24
 611 0294 9093 0000 		sts TaskOne+23+1,r25
 612 0298 A093 0000 		sts TaskOne+23+2,r26
 613 029c B093 0000 		sts TaskOne+23+3,r27
 162:main.c        ****   TaskOne.offset.secs = 0;
 615               	.LM60:
 616 02a0 1092 0000 		sts TaskOne+27,__zero_reg__
 617 02a4 1092 0000 		sts TaskOne+27+1,__zero_reg__
 618 02a8 1092 0000 		sts TaskOne+27+2,__zero_reg__
 619 02ac 1092 0000 		sts TaskOne+27+3,__zero_reg__
 163:main.c        ****   TaskOne.offset.nano_secs= 0;
 621               	.LM61:
 622 02b0 1092 0000 		sts TaskOne+31,__zero_reg__
 623 02b4 1092 0000 		sts TaskOne+31+1,__zero_reg__
 624 02b8 1092 0000 		sts TaskOne+31+2,__zero_reg__
 625 02bc 1092 0000 		sts TaskOne+31+3,__zero_reg__
 164:main.c        ****   
 165:main.c        ****   // @T3 SRP: Task registers which resources it will use.
 166:main.c        ****   //     Indices are in order of the created semaphores.
 167:main.c        ****   for (i = 0; i < NRK_MAX_RESOURCE_CNT; i++)
 168:main.c        ****   	TaskOne.semaphores[i] = false;
 627               	.LM62:
 628 02c0 1092 0000 		sts TaskOne+36,__zero_reg__
 629 02c4 1092 0000 		sts TaskOne+37,__zero_reg__
 630 02c8 1092 0000 		sts TaskOne+38,__zero_reg__
 631 02cc 1092 0000 		sts TaskOne+39,__zero_reg__
 169:main.c        ****   TaskOne.semaphores[0] = true;
 633               	.LM63:
 634 02d0 D092 0000 		sts TaskOne+35,r13
 170:main.c        ****   
 171:main.c        ****   nrk_activate_task (&TaskOne);
 636               	.LM64:
 637 02d4 80E0      		ldi r24,lo8(TaskOne)
 638 02d6 90E0      		ldi r25,hi8(TaskOne)
 639 02d8 0E94 0000 		call nrk_activate_task
 172:main.c        **** 
 173:main.c        ****   TaskTwo.task = Task2;
 641               	.LM65:
 642 02dc 80E0      		ldi r24,lo8(gs(Task2))
 643 02de 90E0      		ldi r25,hi8(gs(Task2))
 644 02e0 9093 0000 		sts TaskTwo+5+1,r25
 645 02e4 8093 0000 		sts TaskTwo+5,r24
 174:main.c        ****   TaskTwo.Ptos = (void *) &Stack2[NRK_APP_STACKSIZE];
 647               	.LM66:
 648 02e8 80E0      		ldi r24,lo8(Stack2+128)
 649 02ea 90E0      		ldi r25,hi8(Stack2+128)
 650 02ec 9093 0000 		sts TaskTwo+1+1,r25
 651 02f0 8093 0000 		sts TaskTwo+1,r24
 175:main.c        ****   TaskTwo.Pbos = (void *) &Stack2[0];
 653               	.LM67:
 654 02f4 80E0      		ldi r24,lo8(Stack2)
 655 02f6 90E0      		ldi r25,hi8(Stack2)
 656 02f8 9093 0000 		sts TaskTwo+3+1,r25
 657 02fc 8093 0000 		sts TaskTwo+3,r24
 176:main.c        ****   TaskTwo.prio = 4;
 659               	.LM68:
 660 0300 84E0      		ldi r24,lo8(4)
 661 0302 8093 0000 		sts TaskTwo+8,r24
 177:main.c        ****   TaskTwo.FirstActivation = TRUE;
 663               	.LM69:
 664 0306 D092 0000 		sts TaskTwo+7,r13
 178:main.c        ****   TaskTwo.Type = BASIC_TASK;
 666               	.LM70:
 667 030a D092 0000 		sts TaskTwo+9,r13
 179:main.c        ****   TaskTwo.SchType = PREEMPTIVE;
 669               	.LM71:
 670 030e D092 0000 		sts TaskTwo+10,r13
 180:main.c        ****   TaskTwo.period.secs = 2;
 672               	.LM72:
 673 0312 82E0      		ldi r24,lo8(2)
 674 0314 90E0      		ldi r25,hi8(2)
 675 0316 A0E0      		ldi r26,hlo8(2)
 676 0318 B0E0      		ldi r27,hhi8(2)
 677 031a 8093 0000 		sts TaskTwo+11,r24
 678 031e 9093 0000 		sts TaskTwo+11+1,r25
 679 0322 A093 0000 		sts TaskTwo+11+2,r26
 680 0326 B093 0000 		sts TaskTwo+11+3,r27
 181:main.c        ****   TaskTwo.period.nano_secs = 0;
 682               	.LM73:
 683 032a 1092 0000 		sts TaskTwo+15,__zero_reg__
 684 032e 1092 0000 		sts TaskTwo+15+1,__zero_reg__
 685 0332 1092 0000 		sts TaskTwo+15+2,__zero_reg__
 686 0336 1092 0000 		sts TaskTwo+15+3,__zero_reg__
 182:main.c        ****   TaskTwo.cpu_reserve.secs = 0;
 688               	.LM74:
 689 033a 1092 0000 		sts TaskTwo+19,__zero_reg__
 690 033e 1092 0000 		sts TaskTwo+19+1,__zero_reg__
 691 0342 1092 0000 		sts TaskTwo+19+2,__zero_reg__
 692 0346 1092 0000 		sts TaskTwo+19+3,__zero_reg__
 183:main.c        ****   TaskTwo.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 694               	.LM75:
 695 034a E12C      		mov r14,__zero_reg__
 696 034c 81EE      		ldi r24,hi8(100000000)
 697 034e F82E      		mov r15,r24
 698 0350 85EF      		ldi r24,hlo8(100000000)
 699 0352 082F      		mov r16,r24
 700 0354 85E0      		ldi r24,hhi8(100000000)
 701 0356 182F      		mov r17,r24
 702 0358 E092 0000 		sts TaskTwo+23,r14
 703 035c F092 0000 		sts TaskTwo+23+1,r15
 704 0360 0093 0000 		sts TaskTwo+23+2,r16
 705 0364 1093 0000 		sts TaskTwo+23+3,r17
 184:main.c        ****   TaskTwo.offset.secs = 0;
 707               	.LM76:
 708 0368 1092 0000 		sts TaskTwo+27,__zero_reg__
 709 036c 1092 0000 		sts TaskTwo+27+1,__zero_reg__
 710 0370 1092 0000 		sts TaskTwo+27+2,__zero_reg__
 711 0374 1092 0000 		sts TaskTwo+27+3,__zero_reg__
 185:main.c        ****   TaskTwo.offset.nano_secs= 0;
 713               	.LM77:
 714 0378 1092 0000 		sts TaskTwo+31,__zero_reg__
 715 037c 1092 0000 		sts TaskTwo+31+1,__zero_reg__
 716 0380 1092 0000 		sts TaskTwo+31+2,__zero_reg__
 717 0384 1092 0000 		sts TaskTwo+31+3,__zero_reg__
 186:main.c        **** 
 187:main.c        ****   // @T3 SRP: Task registers which resources it will use.
 188:main.c        ****   //          Indices are in order of the created semaphores.
 189:main.c        ****   for (i = 0; i < NRK_MAX_RESOURCE_CNT; i++) 
 190:main.c        ****         TaskTwo.semaphores[i] = false;
 719               	.LM78:
 720 0388 1092 0000 		sts TaskTwo+36,__zero_reg__
 721 038c 1092 0000 		sts TaskTwo+37,__zero_reg__
 722 0390 1092 0000 		sts TaskTwo+38,__zero_reg__
 723 0394 1092 0000 		sts TaskTwo+39,__zero_reg__
 191:main.c        ****   TaskTwo.semaphores[0] = true;
 725               	.LM79:
 726 0398 D092 0000 		sts TaskTwo+35,r13
 192:main.c        **** 
 193:main.c        ****   nrk_activate_task (&TaskTwo);
 728               	.LM80:
 729 039c 80E0      		ldi r24,lo8(TaskTwo)
 730 039e 90E0      		ldi r25,hi8(TaskTwo)
 731 03a0 0E94 0000 		call nrk_activate_task
 194:main.c        **** 
 195:main.c        ****   TaskThree.task = Task3;
 733               	.LM81:
 734 03a4 80E0      		ldi r24,lo8(gs(Task3))
 735 03a6 90E0      		ldi r25,hi8(gs(Task3))
 736 03a8 9093 0000 		sts TaskThree+5+1,r25
 737 03ac 8093 0000 		sts TaskThree+5,r24
 196:main.c        ****   TaskThree.Ptos = (void *) &Stack3[NRK_APP_STACKSIZE];
 739               	.LM82:
 740 03b0 80E0      		ldi r24,lo8(Stack3+128)
 741 03b2 90E0      		ldi r25,hi8(Stack3+128)
 742 03b4 9093 0000 		sts TaskThree+1+1,r25
 743 03b8 8093 0000 		sts TaskThree+1,r24
 197:main.c        ****   TaskThree.Pbos = (void *) &Stack3[0];
 745               	.LM83:
 746 03bc 80E0      		ldi r24,lo8(Stack3)
 747 03be 90E0      		ldi r25,hi8(Stack3)
 748 03c0 9093 0000 		sts TaskThree+3+1,r25
 749 03c4 8093 0000 		sts TaskThree+3,r24
 198:main.c        ****   TaskThree.prio = 3;
 751               	.LM84:
 752 03c8 83E0      		ldi r24,lo8(3)
 753 03ca 8093 0000 		sts TaskThree+8,r24
 199:main.c        ****   TaskThree.FirstActivation = TRUE;
 755               	.LM85:
 756 03ce D092 0000 		sts TaskThree+7,r13
 200:main.c        ****   TaskThree.Type = BASIC_TASK;
 758               	.LM86:
 759 03d2 D092 0000 		sts TaskThree+9,r13
 201:main.c        ****   TaskThree.SchType = PREEMPTIVE;
 761               	.LM87:
 762 03d6 D092 0000 		sts TaskThree+10,r13
 202:main.c        ****   TaskThree.period.secs = 0;
 764               	.LM88:
 765 03da 1092 0000 		sts TaskThree+11,__zero_reg__
 766 03de 1092 0000 		sts TaskThree+11+1,__zero_reg__
 767 03e2 1092 0000 		sts TaskThree+11+2,__zero_reg__
 768 03e6 1092 0000 		sts TaskThree+11+3,__zero_reg__
 203:main.c        ****   TaskThree.period.nano_secs = 500*NANOS_PER_MS;
 770               	.LM89:
 771 03ea 80E0      		ldi r24,lo8(500000000)
 772 03ec 95E6      		ldi r25,hi8(500000000)
 773 03ee ADEC      		ldi r26,hlo8(500000000)
 774 03f0 BDE1      		ldi r27,hhi8(500000000)
 775 03f2 8093 0000 		sts TaskThree+15,r24
 776 03f6 9093 0000 		sts TaskThree+15+1,r25
 777 03fa A093 0000 		sts TaskThree+15+2,r26
 778 03fe B093 0000 		sts TaskThree+15+3,r27
 204:main.c        ****   TaskThree.cpu_reserve.secs = 0;
 780               	.LM90:
 781 0402 1092 0000 		sts TaskThree+19,__zero_reg__
 782 0406 1092 0000 		sts TaskThree+19+1,__zero_reg__
 783 040a 1092 0000 		sts TaskThree+19+2,__zero_reg__
 784 040e 1092 0000 		sts TaskThree+19+3,__zero_reg__
 205:main.c        ****   TaskThree.cpu_reserve.nano_secs = 100*NANOS_PER_MS;
 786               	.LM91:
 787 0412 E092 0000 		sts TaskThree+23,r14
 788 0416 F092 0000 		sts TaskThree+23+1,r15
 789 041a 0093 0000 		sts TaskThree+23+2,r16
 790 041e 1093 0000 		sts TaskThree+23+3,r17
 206:main.c        ****   TaskThree.offset.secs = 0;
 792               	.LM92:
 793 0422 1092 0000 		sts TaskThree+27,__zero_reg__
 794 0426 1092 0000 		sts TaskThree+27+1,__zero_reg__
 795 042a 1092 0000 		sts TaskThree+27+2,__zero_reg__
 796 042e 1092 0000 		sts TaskThree+27+3,__zero_reg__
 207:main.c        ****   TaskThree.offset.nano_secs= 0;
 798               	.LM93:
 799 0432 1092 0000 		sts TaskThree+31,__zero_reg__
 800 0436 1092 0000 		sts TaskThree+31+1,__zero_reg__
 801 043a 1092 0000 		sts TaskThree+31+2,__zero_reg__
 802 043e 1092 0000 		sts TaskThree+31+3,__zero_reg__
 208:main.c        **** 
 209:main.c        ****   // @T3 SRP: Task registers which resources it will use.
 210:main.c        ****   //          Indices are in order of the created semaphores.
 211:main.c        ****   for (i = 0; i < NRK_MAX_RESOURCE_CNT; i++) 
 212:main.c        ****         TaskThree.semaphores[i] = false;
 804               	.LM94:
 805 0442 1092 0000 		sts TaskThree+36,__zero_reg__
 806 0446 1092 0000 		sts TaskThree+37,__zero_reg__
 807 044a 1092 0000 		sts TaskThree+38,__zero_reg__
 808 044e 1092 0000 		sts TaskThree+39,__zero_reg__
 213:main.c        ****   TaskThree.semaphores[0] = true;
 810               	.LM95:
 811 0452 D092 0000 		sts TaskThree+35,r13
 214:main.c        **** 
 215:main.c        ****   nrk_activate_task (&TaskThree);
 813               	.LM96:
 814 0456 80E0      		ldi r24,lo8(TaskThree)
 815 0458 90E0      		ldi r25,hi8(TaskThree)
 816 045a 0E94 0000 		call nrk_activate_task
 817               	/* epilogue start */
 216:main.c        **** }
 819               	.LM97:
 820 045e 1F91      		pop r17
 821 0460 0F91      		pop r16
 822 0462 FF90      		pop r15
 823 0464 EF90      		pop r14
 824 0466 DF90      		pop r13
 825 0468 0895      		ret
 827               	.Lscope4:
 829               		.stabd	78,0,0
 830               		.data
 831               	.LC7:
 832 0074 5374 6172 		.string	"Starting up...\r"
 832      7469 6E67 
 832      2075 702E 
 832      2E2E 0D00 
 833               		.text
 835               	.global	main
 837               	main:
 838               		.stabd	46,0,0
  56:main.c        **** {
 840               	.LM98:
 841               	.LFBB5:
 842               	/* prologue: function */
 843               	/* frame size = 0 */
 844               	/* stack size = 0 */
 845               	.L__stack_usage = 0
  58:main.c        ****   nrk_setup_ports();
 847               	.LM99:
 848 046a 0E94 0000 		call nrk_setup_ports
  59:main.c        ****   nrk_setup_uart(UART_BAUDRATE_115K2);
 850               	.LM100:
 851 046e 87E0      		ldi r24,lo8(7)
 852 0470 90E0      		ldi r25,hi8(7)
 853 0472 0E94 0000 		call nrk_setup_uart
  61:main.c        ****   printf( "Starting up...\r\n" );
 855               	.LM101:
 856 0476 80E0      		ldi r24,lo8(.LC7)
 857 0478 90E0      		ldi r25,hi8(.LC7)
 858 047a 0E94 0000 		call puts
  63:main.c        ****   nrk_init();
 860               	.LM102:
 861 047e 0E94 0000 		call nrk_init
  65:main.c        ****   nrk_led_clr(ORANGE_LED);
 863               	.LM103:
 864 0482 80E0      		ldi r24,lo8(0)
 865 0484 90E0      		ldi r25,hi8(0)
 866 0486 0E94 0000 		call nrk_led_clr
  66:main.c        ****   nrk_led_clr(BLUE_LED);
 868               	.LM104:
 869 048a 8FEF      		ldi r24,lo8(255)
 870 048c 90E0      		ldi r25,hi8(255)
 871 048e 0E94 0000 		call nrk_led_clr
  67:main.c        ****   nrk_led_set(GREEN_LED);
 873               	.LM105:
 874 0492 81E0      		ldi r24,lo8(1)
 875 0494 90E0      		ldi r25,hi8(1)
 876 0496 0E94 0000 		call nrk_led_set
  68:main.c        ****   nrk_led_clr(RED_LED);
 878               	.LM106:
 879 049a 82E0      		ldi r24,lo8(2)
 880 049c 90E0      		ldi r25,hi8(2)
 881 049e 0E94 0000 		call nrk_led_clr
  70:main.c        ****   nrk_time_set(0,0);
 883               	.LM107:
 884 04a2 60E0      		ldi r22,lo8(0)
 885 04a4 70E0      		ldi r23,hi8(0)
 886 04a6 CB01      		movw r24,r22
 887 04a8 20E0      		ldi r18,lo8(0)
 888 04aa 30E0      		ldi r19,hi8(0)
 889 04ac A901      		movw r20,r18
 890 04ae 0E94 0000 		call nrk_time_set
  71:main.c        ****   nrk_create_taskset ();
 892               	.LM108:
 893 04b2 0E94 0000 		call nrk_create_taskset
  73:main.c        ****   my_semaphore = nrk_sem_create(1,2);
 895               	.LM109:
 896 04b6 81E0      		ldi r24,lo8(1)
 897 04b8 62E0      		ldi r22,lo8(2)
 898 04ba 0E94 0000 		call nrk_sem_create
 899 04be 9093 0000 		sts my_semaphore+1,r25
 900 04c2 8093 0000 		sts my_semaphore,r24
  74:main.c        ****   if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
 902               	.LM110:
 903 04c6 0097      		sbiw r24,0
 904 04c8 01F4      		brne .L13
  74:main.c        ****   if(my_semaphore==NULL) nrk_kprintf( PSTR("Error creating sem\r\n" ));
 906               	.LM111:
 907 04ca 80E0      		ldi r24,lo8(__c.2125)
 908 04cc 90E0      		ldi r25,hi8(__c.2125)
 909 04ce 0E94 0000 		call nrk_kprintf
 910               	.L13:
  75:main.c        ****   nrk_start();
 912               	.LM112:
 913 04d2 0E94 0000 		call nrk_start
  78:main.c        **** }
 915               	.LM113:
 916 04d6 80E0      		ldi r24,lo8(0)
 917 04d8 90E0      		ldi r25,hi8(0)
 918               	/* epilogue start */
 919 04da 0895      		ret
 921               	.Lscope5:
 923               		.stabd	78,0,0
 924               		.comm _nrk_signal_list,4,1
 925               		.comm nrk_system_ceiling,2,1
 926               		.comm nrk_idle_task_stk,128,1
 927               		.comm nrk_kernel_stk_ptr,2,1
 928               		.comm error_task,1,1
 929               		.comm error_num,1,1
 930               		.comm _nrk_prev_timer_val,1,1
 931               		.comm _nrk_time_trigger,1,1
 932               		.comm app_timer0_callback,2,1
 933               		.comm app_timer0_prescale,1,1
 934               		.comm Stack1,128,1
 935               		.comm TaskOne,40,1
 936               		.comm Stack2,128,1
 937               		.comm TaskTwo,40,1
 938               		.comm Stack3,128,1
 939               		.comm TaskThree,40,1
 940               		.comm my_semaphore,2,1
 941               		.section	.progmem.data,"a",@progbits
 944               	__c.2154:
 945 0000 5461 736B 		.string	"Task2 released semaphore\r\n"
 945      3220 7265 
 945      6C65 6173 
 945      6564 2073 
 945      656D 6170 
 948               	__c.2152:
 949 001b 5432 2065 		.string	"T2 error post\r\n"
 949      7272 6F72 
 949      2070 6F73 
 949      740D 0A00 
 952               	__c.2150:
 953 002b 5461 736B 		.string	"Task2 holding semaphore\r\n"
 953      3220 686F 
 953      6C64 696E 
 953      6720 7365 
 953      6D61 7068 
 956               	__c.2148:
 957 0045 5432 2065 		.string	"T2 error pend\r\n"
 957      7272 6F72 
 957      2070 656E 
 957      640D 0A00 
 960               	__c.2146:
 961 0055 5461 736B 		.string	"Task2 accessing semaphore\r\n"
 961      3220 6163 
 961      6365 7373 
 961      696E 6720 
 961      7365 6D61 
 964               	__c.2139:
 965 0071 5461 736B 		.string	"Task1 released semaphore\r\n"
 965      3120 7265 
 965      6C65 6173 
 965      6564 2073 
 965      656D 6170 
 968               	__c.2137:
 969 008c 5431 2065 		.string	"T1 error post\r\n"
 969      7272 6F72 
 969      2070 6F73 
 969      740D 0A00 
 972               	__c.2135:
 973 009c 5461 736B 		.string	"Task1 holding semaphore\r\n"
 973      3120 686F 
 973      6C64 696E 
 973      6720 7365 
 973      6D61 7068 
 976               	__c.2133:
 977 00b6 5431 2065 		.string	"T1 error pend\r\n"
 977      7272 6F72 
 977      2070 656E 
 977      640D 0A00 
 980               	__c.2131:
 981 00c6 5461 736B 		.string	"Task1 accessing semaphore\r\n"
 981      3120 6163 
 981      6365 7373 
 981      696E 6720 
 981      7365 6D61 
 984               	__c.2125:
 985 00e2 4572 726F 		.string	"Error creating sem\r\n"
 985      7220 6372 
 985      6561 7469 
 985      6E67 2073 
 985      656D 0D0A 
 1003               		.text
 1005               	.Letext0:
 1006               	.global __do_copy_data
 1007               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 main.c
     /tmp/ccpUdkcC.s:2      *ABS*:0000003f __SREG__
     /tmp/ccpUdkcC.s:3      *ABS*:0000003e __SP_H__
     /tmp/ccpUdkcC.s:4      *ABS*:0000003d __SP_L__
     /tmp/ccpUdkcC.s:5      *ABS*:00000034 __CCP__
     /tmp/ccpUdkcC.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/ccpUdkcC.s:7      *ABS*:00000001 __zero_reg__
     /tmp/ccpUdkcC.s:146    .text:00000000 Task3
     /tmp/ccpUdkcC.s:234    .text:0000006a Task2
     /tmp/ccpUdkcC.s:960    .progmem.data:00000055 __c.2146
                            *COM*:00000002 my_semaphore
     /tmp/ccpUdkcC.s:956    .progmem.data:00000045 __c.2148
     /tmp/ccpUdkcC.s:952    .progmem.data:0000002b __c.2150
     /tmp/ccpUdkcC.s:948    .progmem.data:0000001b __c.2152
     /tmp/ccpUdkcC.s:944    .progmem.data:00000000 __c.2154
     /tmp/ccpUdkcC.s:379    .text:0000012a Task1
     /tmp/ccpUdkcC.s:980    .progmem.data:000000c6 __c.2131
     /tmp/ccpUdkcC.s:976    .progmem.data:000000b6 __c.2133
     /tmp/ccpUdkcC.s:972    .progmem.data:0000009c __c.2135
     /tmp/ccpUdkcC.s:968    .progmem.data:0000008c __c.2137
     /tmp/ccpUdkcC.s:964    .progmem.data:00000071 __c.2139
     /tmp/ccpUdkcC.s:535    .text:0000020c nrk_create_taskset
                            *COM*:00000028 TaskOne
                            *COM*:00000080 Stack1
                            *COM*:00000028 TaskTwo
                            *COM*:00000080 Stack2
                            *COM*:00000028 TaskThree
                            *COM*:00000080 Stack3
     /tmp/ccpUdkcC.s:837    .text:0000046a main
     /tmp/ccpUdkcC.s:984    .progmem.data:000000e2 __c.2125
                            *COM*:00000004 _nrk_signal_list
                            *COM*:00000002 nrk_system_ceiling
                            *COM*:00000080 nrk_idle_task_stk
                            *COM*:00000002 nrk_kernel_stk_ptr
                            *COM*:00000001 error_task
                            *COM*:00000001 error_num
                            *COM*:00000001 _nrk_prev_timer_val
                            *COM*:00000001 _nrk_time_trigger
                            *COM*:00000002 app_timer0_callback
                            *COM*:00000001 app_timer0_prescale

UNDEFINED SYMBOLS
nrk_get_pid
printf
nrk_spin_wait_us
nrk_wait_until_next_period
nrk_led_toggle
nrk_kprintf
nrk_sem_pend
nrk_sem_post
nrk_activate_task
nrk_setup_ports
nrk_setup_uart
puts
nrk_init
nrk_led_clr
nrk_led_set
nrk_time_set
nrk_sem_create
nrk_start
__do_copy_data
__do_clear_bss
