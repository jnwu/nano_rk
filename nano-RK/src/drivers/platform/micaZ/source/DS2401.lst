   1               		.file	"DS2401.c"
   2               	__SREG__ = 0x3f
   3               	__SP_H__ = 0x3e
   4               	__SP_L__ = 0x3d
   5               	__CCP__ = 0x34
   6               	__tmp_reg__ = 0
   7               	__zero_reg__ = 1
  10               		.text
  11               	.Ltext0:
 134               	.global	Maxim_1Wire_ResetPulse
 136               	Maxim_1Wire_ResetPulse:
 137               		.stabd	46,0,0
   1:../../../src/drivers/platform/micaZ/source/DS2401.c **** /******************************************************************************
   2:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Nano-RK, a real-time operating system for sensor networks.
   3:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Copyright (C) 2011 Technische Universität München (www.vmi.ei.tum.de)
   4:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  All rights reserved.
   5:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
   6:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  This is the Open Source Version of Nano-RK included as part of a Dual
   7:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Licensing Model. If you are unsure which license to use please refer to:
   8:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  http://www.nanork.org/nano-RK/wiki/Licensing
   9:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  10:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  This program is free software: you can redistribute it and/or modify
  11:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  it under the terms of the GNU General Public License as published by
  12:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  the Free Software Foundation, version 2.0 of the License.
  13:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  14:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  This program is distributed in the hope that it will be useful,
  15:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  but WITHOUT ANY WARRANTY; without even the implied warranty of
  16:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  17:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  GNU General Public License for more details.
  18:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  19:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  You should have received a copy of the GNU General Public License
  20:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
  21:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  22:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  23:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Serial ID Driver for Maxim DS2401.h
  24:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  25:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Contributing Authors (specific to this file):
  26:../../../src/drivers/platform/micaZ/source/DS2401.c **** *  Author: Peter Diener
  27:../../../src/drivers/platform/micaZ/source/DS2401.c **** *
  28:../../../src/drivers/platform/micaZ/source/DS2401.c **** ***************************************************************************************/
  29:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  30:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  31:../../../src/drivers/platform/micaZ/source/DS2401.c **** #include "DS2401.h"
  32:../../../src/drivers/platform/micaZ/source/DS2401.c **** #include <avr/io.h>
  33:../../../src/drivers/platform/micaZ/source/DS2401.c **** #include <util/delay.h>
  34:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  35:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  36:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  37:../../../src/drivers/platform/micaZ/source/DS2401.c **** // DataPin_DriveLow forces a low state to the data pin
  38:../../../src/drivers/platform/micaZ/source/DS2401.c **** #define DataPin_DriveLow   do {OUTPUT &= ~(1 << PIN); DIRECTION |= (1 << PIN);} while(0)
  39:../../../src/drivers/platform/micaZ/source/DS2401.c **** // DataPin_PullUp switches the data pin to input and enables the pullup resistor
  40:../../../src/drivers/platform/micaZ/source/DS2401.c **** #define DataPin_PullUp     do {DIRECTION &= ~(1 << PIN); OUTPUT |= (1 << PIN);} while(0)
  41:../../../src/drivers/platform/micaZ/source/DS2401.c **** // DataPin_State returns 1 if the data pin is high, else 0
  42:../../../src/drivers/platform/micaZ/source/DS2401.c **** #define DataPin_State      ((INPUT & (1 << PIN)) >> PIN)
  43:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  44:../../../src/drivers/platform/micaZ/source/DS2401.c **** // The Maxim 1Wire interface is designed for a slot time of 100µs
  45:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  46:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Applies a reset pulse and checks for the presence pulse of a slave device
  47:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Returns 0 if slave is present, else -1
  48:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline signed char Maxim_1Wire_ResetPulse(void)
  49:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 139               	.LM0:
 140               	.LFBB1:
 141               	/* prologue: function */
 142               	/* frame size = 0 */
 143               	/* stack size = 0 */
 144               	.L__stack_usage = 0
 145               	.LBB26:
 146               	.LBB27:
 148               	.Ltext1:
   1:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    All rights reserved.
   5:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   6:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
   9:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  12:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      distribution.
  16:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  17:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  21:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  33:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* $Id: delay.h.in 2189 2010-10-13 09:39:34Z aboyapati $ */
  34:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  35:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  38:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __HAS_DELAY_CYCLES
  39:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #define __HAS_DELAY_CYCLES 1
  40:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  41:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  42:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <inttypes.h>
  43:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <util/delay_basic.h>
  44:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #include <math.h>
  45:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  46:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \file */
  47:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  48:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \code
  49:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  50:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  51:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     #include <util/delay.h>
  52:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \endcode
  53:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  54:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  55:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  56:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  57:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     used.
  58:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  59:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  60:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  61:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  62:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  63:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  64:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  65:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  66:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  67:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  68:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  69:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  70:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  71:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  72:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  73:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  74:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  75:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     routines linked into the application.
  76:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  77:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  78:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  79:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  80:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  81:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** */
  82:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  83:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  84:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_us(double __us) __attribute__((always_inline));
  85:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** static inline void _delay_ms(double __ms) __attribute__((always_inline));
  86:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  87:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  88:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef F_CPU
  89:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  90:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  91:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # define F_CPU 1000000UL
  92:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  93:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  94:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #ifndef __OPTIMIZE__
  95:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
  96:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
  97:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
  98:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
  99:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 100:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 101:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 102:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 103:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 104:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 105:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 106:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 107:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 108:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 109:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 110:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 111:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 112:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 113:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 114:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 115:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 116:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 117:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0ms.
 118:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 119:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 120:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 121:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 122:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 123:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 124:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 125:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 126:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_ms(double __ms) with 
 127:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible. 
 128:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 129:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 130:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 131:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 132:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 133:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_ms(double __ms)
 134:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 135:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint16_t __ticks;
 136:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 137:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 138:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 139:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 140:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 141:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 142:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 143:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 144:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 145:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 146:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 147:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 148:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 149:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 150:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 151:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 152:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 153:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 154:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 155:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #elif !__HAS_DELAY_CYCLES || (__HAS_DELAY_CYCLES && !defined(__OPTIMIZE__)) || defined (__DELAY_BAC
 156:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 157:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	if (__tmp < 1.0)
 158:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks = 1;
 159:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	else if (__tmp > 65535)
 160:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	{
 161:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 162:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 163:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		while(__ticks)
 164:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		{
 165:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 			// wait 1/10 ms
 166:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 167:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 			__ticks --;
 168:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		}
 169:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		return;
 170:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	}
 171:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	else
 172:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 173:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 174:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #endif
 175:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** }
 176:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 177:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** /**
 178:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    \ingroup util_delay
 179:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 180:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 181:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 182:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 183:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 184:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 185:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 186:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 187:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 188:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 189:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    will not be informed about this case.
 190:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 191:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles(unsigned long)
 192:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 193:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 194:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    no delay i.e., 0us.
 195:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****   
 196:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Conversion of __us into clock cycles may not always result in integer.
 197:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    By default, the clock cycles rounded up to next integer. This ensures that
 198:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    the user gets atleast __us microseconds of delay.
 199:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 200:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Alternatively, user can define __DELAY_ROUND_DOWN__ and __DELAY_ROUND_CLOSEST__
 201:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    to round down and round to closest integer.
 202:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  
 203:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    Note: The new implementation of _delay_us(double __us) with 
 204:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****     __builtin_avr_delay_cycles(unsigned long) support is not backward compatible.
 205:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    User can define __DELAY_BACKWARD_COMPATIBLE__ to get a backward compatible delay
 206:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****    although this will be deprecated in future.
 207:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 208:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h ****  */
 209:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** void
 210:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** _delay_us(double __us)
 211:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** {
 212:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint8_t __ticks;
 213:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	double __tmp ; 
 214:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && !defined(__DELAY_BACKWARD_COMPATIBLE__)
 215:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 216:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 217:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 218:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 219:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 220:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 221:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 222:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 223:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 224:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 225:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#else
 226:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		//round up by default
 227:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 228:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	#endif
 229:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 
 230:/usr/lib/gcc/avr/4.5.3/../../../avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 150               	.LM1:
 151 0000 89E9      		 ldi r24,lo8(921)
 152 0002 93E0      	    ldi r25,hi8(921)
 153 0004 0197      	    1:sbiw r24,1
 154 0006 01F4      	    brne 1b
 155 0008 00C0      		rjmp .
 156               	.LBE27:
 157               	.LBE26:
 159               	.Ltext2:
  50:../../../src/drivers/platform/micaZ/source/DS2401.c ****     unsigned char delaytime = 0;
  51:../../../src/drivers/platform/micaZ/source/DS2401.c ****     _delay_us(500);
  52:../../../src/drivers/platform/micaZ/source/DS2401.c ****     DataPin_DriveLow;
 161               	.LM2:
 162 000a DC98      		cbi 59-32,4
 163 000c D49A      		sbi 58-32,4
 164               	.LBB28:
 165               	.LBB29:
 167               	.Ltext3:
 169               	.LM3:
 170 000e 89E9      		 ldi r24,lo8(921)
 171 0010 93E0      	    ldi r25,hi8(921)
 172 0012 0197      	    1:sbiw r24,1
 173 0014 01F4      	    brne 1b
 174 0016 00C0      		rjmp .
 175               	.LBE29:
 176               	.LBE28:
 178               	.Ltext4:
  53:../../../src/drivers/platform/micaZ/source/DS2401.c ****     _delay_us(500);   // datasheet value: 480 µs
  54:../../../src/drivers/platform/micaZ/source/DS2401.c ****     DataPin_PullUp;
 180               	.LM4:
 181 0018 D498      		cbi 58-32,4
 182 001a DC9A      		sbi 59-32,4
 183               	.L2:
  55:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  56:../../../src/drivers/platform/micaZ/source/DS2401.c ****     // Wait for data line to go high
  57:../../../src/drivers/platform/micaZ/source/DS2401.c ****     while (DataPin_State == 0);
 185               	.LM5:
 186 001c CC9B      		sbis 57-32,4
 187 001e 00C0      		rjmp .L2
 189               	.LM6:
 190 0020 80E0      		ldi r24,lo8(0)
 191 0022 00C0      		rjmp .L5
 192               	.L6:
 193               	.LBB30:
 194               	.LBB31:
 196               	.Ltext5:
 198               	.LM7:
 199 0024 91E3      		 ldi r25,lo8(49)
 200 0026 9A95      	    1:dec r25
 201 0028 01F4      	    brne 1b
 202 002a 0000      		nop
 203               	.LBE31:
 204               	.LBE30:
 206               	.Ltext6:
  58:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  59:../../../src/drivers/platform/micaZ/source/DS2401.c ****     // Wait for presence pulse
  60:../../../src/drivers/platform/micaZ/source/DS2401.c ****     while (DataPin_State == 1)
  61:../../../src/drivers/platform/micaZ/source/DS2401.c ****     {
  62:../../../src/drivers/platform/micaZ/source/DS2401.c ****         _delay_us(20);
  63:../../../src/drivers/platform/micaZ/source/DS2401.c ****         delaytime ++;
 208               	.LM8:
 209 002c 8F5F      		subi r24,lo8(-(1))
  64:../../../src/drivers/platform/micaZ/source/DS2401.c ****         if (delaytime > 30) return -1;  // Timeout 600 µs: no presence pulse detected
 211               	.LM9:
 212 002e 8F31      		cpi r24,lo8(31)
 213 0030 01F0      		breq .L7
 214               	.L5:
  60:../../../src/drivers/platform/micaZ/source/DS2401.c ****     while (DataPin_State == 1)
 216               	.LM10:
 217 0032 CC99      		sbic 57-32,4
 218 0034 00C0      		rjmp .L6
 219               	.LBB32:
 220               	.LBB33:
 222               	.Ltext7:
 224               	.LM11:
 225 0036 89E9      		 ldi r24,lo8(921)
 226 0038 93E0      	    ldi r25,hi8(921)
 227 003a 0197      	    1:sbiw r24,1
 228 003c 01F4      	    brne 1b
 229 003e 00C0      		rjmp .
 230               	.LBE33:
 231               	.LBE32:
 233               	.Ltext8:
  65:../../../src/drivers/platform/micaZ/source/DS2401.c ****     }
  66:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  67:../../../src/drivers/platform/micaZ/source/DS2401.c ****     // Presence pulse detected, wait until bus is free
  68:../../../src/drivers/platform/micaZ/source/DS2401.c ****     _delay_us(500);   // Datasheet: Trsth
  69:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  70:../../../src/drivers/platform/micaZ/source/DS2401.c ****     return 0;
 235               	.LM12:
 236 0040 80E0      		ldi r24,lo8(0)
 237 0042 0895      		ret
 238               	.L7:
  64:../../../src/drivers/platform/micaZ/source/DS2401.c ****         if (delaytime > 30) return -1;  // Timeout 600 µs: no presence pulse detected
 240               	.LM13:
 241 0044 8FEF      		ldi r24,lo8(-1)
  71:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 243               	.LM14:
 244 0046 0895      		ret
 249               	.Lscope1:
 251               		.stabd	78,0,0
 254               	.global	Maxim_1Wire_WriteBit
 256               	Maxim_1Wire_WriteBit:
 257               		.stabd	46,0,0
  72:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  73:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  74:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Write will take a 100 µs time slot and write one or zero
  75:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Wrtie One will pull low for 10 µs
  76:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Write Zero will pull down for 80 µs
  77:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline void Maxim_1Wire_WriteBit(unsigned char databit)
  78:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 259               	.LM15:
 260               	.LFBB2:
 261               	/* prologue: function */
 262               	/* frame size = 0 */
 263               	/* stack size = 0 */
 264               	.L__stack_usage = 0
  79:../../../src/drivers/platform/micaZ/source/DS2401.c ****    if (databit == 0) // Write Zero
 266               	.LM16:
 267 0048 8823      		tst r24
 268 004a 01F4      		brne .L10
  80:../../../src/drivers/platform/micaZ/source/DS2401.c ****    {
  81:../../../src/drivers/platform/micaZ/source/DS2401.c ****       DataPin_DriveLow;
 270               	.LM17:
 271 004c DC98      		cbi 59-32,4
 272 004e D49A      		sbi 58-32,4
 273               	.LBB34:
 274               	.LBB35:
 276               	.Ltext9:
 278               	.LM18:
 279 0050 84EC      		 ldi r24,lo8(-60)
 280 0052 8A95      	    1:dec r24
 281 0054 01F4      	    brne 1b
 282 0056 00C0      		rjmp .
 283               	.LBE35:
 284               	.LBE34:
 286               	.Ltext10:
  82:../../../src/drivers/platform/micaZ/source/DS2401.c ****       _delay_us(80);    //80
  83:../../../src/drivers/platform/micaZ/source/DS2401.c ****       DataPin_PullUp;
 288               	.LM19:
 289 0058 D498      		cbi 58-32,4
 290 005a DC9A      		sbi 59-32,4
 291               	.LBB36:
 292               	.LBB37:
 294               	.Ltext11:
 296               	.LM20:
 297 005c 81E3      		 ldi r24,lo8(49)
 298 005e 8A95      	    1:dec r24
 299 0060 01F4      	    brne 1b
 300 0062 00C0      		rjmp .L12
 301               	.L10:
 302               	.LBE37:
 303               	.LBE36:
 305               	.Ltext12:
  84:../../../src/drivers/platform/micaZ/source/DS2401.c ****       _delay_us(20);    //20
  85:../../../src/drivers/platform/micaZ/source/DS2401.c ****    }
  86:../../../src/drivers/platform/micaZ/source/DS2401.c ****    else              // Write One
  87:../../../src/drivers/platform/micaZ/source/DS2401.c ****    {
  88:../../../src/drivers/platform/micaZ/source/DS2401.c ****       DataPin_DriveLow;
 307               	.LM21:
 308 0064 DC98      		cbi 59-32,4
 309 0066 D49A      		sbi 58-32,4
 310               	.LBB38:
 311               	.LBB39:
 313               	.Ltext13:
 315               	.LM22:
 316 0068 88E1      		 ldi r24,lo8(24)
 317 006a 8A95      	    1:dec r24
 318 006c 01F4      	    brne 1b
 319 006e 00C0      		rjmp .
 320               	.LBE39:
 321               	.LBE38:
 323               	.Ltext14:
  89:../../../src/drivers/platform/micaZ/source/DS2401.c ****       _delay_us(10);    //10
  90:../../../src/drivers/platform/micaZ/source/DS2401.c ****       DataPin_PullUp;
 325               	.LM23:
 326 0070 D498      		cbi 58-32,4
 327 0072 DC9A      		sbi 59-32,4
 328               	.LBB40:
 329               	.LBB41:
 331               	.Ltext15:
 333               	.LM24:
 334 0074 8DED      		 ldi r24,lo8(-35)
 335 0076 8A95      	    1:dec r24
 336 0078 01F4      	    brne 1b
 337               	.L12:
 338 007a 0000      		nop
 339 007c 0895      		ret
 340               	.LBE41:
 341               	.LBE40:
 343               	.Lscope2:
 345               		.stabd	78,0,0
 347               	.global	Maxim_1Wire_ReadBit
 349               	Maxim_1Wire_ReadBit:
 350               		.stabd	46,0,0
 352               	.Ltext16:
  91:../../../src/drivers/platform/micaZ/source/DS2401.c ****       _delay_us(90);    //90
  92:../../../src/drivers/platform/micaZ/source/DS2401.c ****    }
  93:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
  94:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  95:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  96:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
  97:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Reads a bit
  98:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline unsigned char Maxim_1Wire_ReadBit(void)
  99:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 354               	.LM25:
 355               	.LFBB3:
 356               	/* prologue: function */
 357               	/* frame size = 0 */
 358               	/* stack size = 0 */
 359               	.L__stack_usage = 0
 100:../../../src/drivers/platform/micaZ/source/DS2401.c ****    unsigned char bit;
 101:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 102:../../../src/drivers/platform/micaZ/source/DS2401.c ****    DataPin_DriveLow;
 361               	.LM26:
 362 007e DC98      		cbi 59-32,4
 363 0080 D49A      		sbi 58-32,4
 364               	.LBB42:
 365               	.LBB43:
 367               	.Ltext17:
 369               	.LM27:
 370 0082 82E0      		 ldi r24,lo8(2)
 371 0084 8A95      	    1:dec r24
 372 0086 01F4      	    brne 1b
 373 0088 00C0      		rjmp .
 374               	.LBE43:
 375               	.LBE42:
 377               	.Ltext18:
 103:../../../src/drivers/platform/micaZ/source/DS2401.c ****    _delay_us(1);    //1
 104:../../../src/drivers/platform/micaZ/source/DS2401.c ****    DataPin_PullUp;
 379               	.LM28:
 380 008a D498      		cbi 58-32,4
 381 008c DC9A      		sbi 59-32,4
 382               	.LBB44:
 383               	.LBB45:
 385               	.Ltext19:
 387               	.LM29:
 388 008e 96E1      		 ldi r25,lo8(22)
 389 0090 9A95      	    1:dec r25
 390 0092 01F4      	    brne 1b
 391 0094 0000      		nop
 392               	.LBE45:
 393               	.LBE44:
 395               	.Ltext20:
 105:../../../src/drivers/platform/micaZ/source/DS2401.c ****    _delay_us(9);   //9
 106:../../../src/drivers/platform/micaZ/source/DS2401.c ****    bit = DataPin_State;
 397               	.LM30:
 398 0096 89B3      		in r24,57-32
 399               	.LBB46:
 400               	.LBB47:
 402               	.Ltext21:
 404               	.LM31:
 405 0098 94EC      		 ldi r25,lo8(-60)
 406 009a 9A95      	    1:dec r25
 407 009c 01F4      	    brne 1b
 408 009e 00C0      		rjmp .
 409               	.LBE47:
 410               	.LBE46:
 412               	.Ltext22:
 414               	.LM32:
 415 00a0 90E0      		ldi r25,lo8(0)
 416 00a2 8071      		andi r24,lo8(16)
 417 00a4 9070      		andi r25,hi8(16)
 418 00a6 24E0      		ldi r18,4
 419 00a8 9595      	1:	asr r25
 420 00aa 8795      		ror r24
 421 00ac 2A95      		dec r18
 422 00ae 01F4      		brne 1b
 423               	/* epilogue start */
 107:../../../src/drivers/platform/micaZ/source/DS2401.c ****    _delay_us(80);   //80
 108:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 109:../../../src/drivers/platform/micaZ/source/DS2401.c ****    return bit;
 110:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 425               	.LM33:
 426 00b0 0895      		ret
 428               	.Lscope3:
 430               		.stabd	78,0,0
 433               	.global	Maxim_1Wire_WriteByte
 435               	Maxim_1Wire_WriteByte:
 436               		.stabd	46,0,0
 111:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 112:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 113:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline void Maxim_1Wire_WriteByte(unsigned char data)
 114:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 438               	.LM34:
 439               	.LFBB4:
 440 00b2 FF92      		push r15
 441 00b4 0F93      		push r16
 442 00b6 1F93      		push r17
 443 00b8 CF93      		push r28
 444 00ba DF93      		push r29
 445               	/* prologue: function */
 446               	/* frame size = 0 */
 447               	/* stack size = 5 */
 448               	.L__stack_usage = 5
 449 00bc F82E      		mov r15,r24
 451               	.LM35:
 452 00be C0E0      		ldi r28,lo8(0)
 453 00c0 D0E0      		ldi r29,hi8(0)
 115:../../../src/drivers/platform/micaZ/source/DS2401.c ****    // Data order is lsb first
 116:../../../src/drivers/platform/micaZ/source/DS2401.c ****    unsigned char currentBit;
 117:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 118:../../../src/drivers/platform/micaZ/source/DS2401.c ****    for (currentBit = 0; currentBit < 8; currentBit++)
 119:../../../src/drivers/platform/micaZ/source/DS2401.c ****    {
 120:../../../src/drivers/platform/micaZ/source/DS2401.c ****       Maxim_1Wire_WriteBit(data & (1 << currentBit));
 455               	.LM36:
 456 00c2 01E0      		ldi r16,lo8(1)
 457 00c4 10E0      		ldi r17,hi8(1)
 458               	.L15:
 460               	.LM37:
 461 00c6 9801      		movw r18,r16
 462 00c8 0C2E      		mov r0,r28
 463 00ca 00C0      		rjmp 2f
 464 00cc 220F      	1:	lsl r18
 465 00ce 331F      		rol r19
 466 00d0 0A94      	2:	dec r0
 467 00d2 02F4      		brpl 1b
 468 00d4 8F2D      		mov r24,r15
 469 00d6 8223      		and r24,r18
 470 00d8 0E94 0000 		call Maxim_1Wire_WriteBit
 471 00dc 2196      		adiw r28,1
 118:../../../src/drivers/platform/micaZ/source/DS2401.c ****    for (currentBit = 0; currentBit < 8; currentBit++)
 473               	.LM38:
 474 00de C830      		cpi r28,8
 475 00e0 D105      		cpc r29,__zero_reg__
 476 00e2 01F4      		brne .L15
 477               	/* epilogue start */
 121:../../../src/drivers/platform/micaZ/source/DS2401.c ****    }
 122:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 479               	.LM39:
 480 00e4 DF91      		pop r29
 481 00e6 CF91      		pop r28
 482 00e8 1F91      		pop r17
 483 00ea 0F91      		pop r16
 484 00ec FF90      		pop r15
 485 00ee 0895      		ret
 487               	.Lscope4:
 489               		.stabd	78,0,0
 491               	.global	Maxim_1Wire_ReadByte
 493               	Maxim_1Wire_ReadByte:
 494               		.stabd	46,0,0
 123:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 124:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 125:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline unsigned char Maxim_1Wire_ReadByte(void)
 126:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 496               	.LM40:
 497               	.LFBB5:
 498 00f0 1F93      		push r17
 499 00f2 CF93      		push r28
 500 00f4 DF93      		push r29
 501               	/* prologue: function */
 502               	/* frame size = 0 */
 503               	/* stack size = 3 */
 504               	.L__stack_usage = 3
 506               	.LM41:
 507 00f6 C0E0      		ldi r28,lo8(0)
 508 00f8 D0E0      		ldi r29,hi8(0)
 127:../../../src/drivers/platform/micaZ/source/DS2401.c ****    // Data order is lsb first
 128:../../../src/drivers/platform/micaZ/source/DS2401.c ****    unsigned char data = 0;
 510               	.LM42:
 511 00fa 10E0      		ldi r17,lo8(0)
 512               	.L18:
 129:../../../src/drivers/platform/micaZ/source/DS2401.c ****    unsigned char currentBit;
 130:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 131:../../../src/drivers/platform/micaZ/source/DS2401.c ****    for (currentBit = 0; currentBit < 8; currentBit++)
 132:../../../src/drivers/platform/micaZ/source/DS2401.c ****    {
 133:../../../src/drivers/platform/micaZ/source/DS2401.c ****       data |= (Maxim_1Wire_ReadBit() << currentBit);
 514               	.LM43:
 515 00fc 0E94 0000 		call Maxim_1Wire_ReadBit
 516 0100 282F      		mov r18,r24
 517 0102 30E0      		ldi r19,lo8(0)
 518 0104 0C2E      		mov r0,r28
 519 0106 00C0      		rjmp 2f
 520 0108 220F      	1:	lsl r18
 521 010a 331F      		rol r19
 522 010c 0A94      	2:	dec r0
 523 010e 02F4      		brpl 1b
 524 0110 122B      		or r17,r18
 525 0112 2196      		adiw r28,1
 131:../../../src/drivers/platform/micaZ/source/DS2401.c ****    for (currentBit = 0; currentBit < 8; currentBit++)
 527               	.LM44:
 528 0114 C830      		cpi r28,8
 529 0116 D105      		cpc r29,__zero_reg__
 530 0118 01F4      		brne .L18
 134:../../../src/drivers/platform/micaZ/source/DS2401.c ****    }
 135:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 136:../../../src/drivers/platform/micaZ/source/DS2401.c ****    return data;
 137:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 532               	.LM45:
 533 011a 812F      		mov r24,r17
 534               	/* epilogue start */
 535 011c DF91      		pop r29
 536 011e CF91      		pop r28
 537 0120 1F91      		pop r17
 538 0122 0895      		ret
 543               	.Lscope5:
 545               		.stabd	78,0,0
 547               	.global	Maxim_1Wire_CommandReadRom
 549               	Maxim_1Wire_CommandReadRom:
 550               		.stabd	46,0,0
 138:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 139:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 140:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 141:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline void Maxim_1Wire_CommandReadRom(void)
 142:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 552               	.LM46:
 553               	.LFBB6:
 554               	/* prologue: function */
 555               	/* frame size = 0 */
 556               	/* stack size = 0 */
 557               	.L__stack_usage = 0
 143:../../../src/drivers/platform/micaZ/source/DS2401.c ****    Maxim_1Wire_WriteByte(0x0f);
 559               	.LM47:
 560 0124 8FE0      		ldi r24,lo8(15)
 561 0126 0E94 0000 		call Maxim_1Wire_WriteByte
 562               	/* epilogue start */
 144:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 564               	.LM48:
 565 012a 0895      		ret
 567               	.Lscope6:
 569               		.stabd	78,0,0
 571               	.global	DS2401_init
 573               	DS2401_init:
 574               		.stabd	46,0,0
 145:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 146:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 147:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 148:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline void DS2401_init(void)
 149:../../../src/drivers/platform/micaZ/source/DS2401.c **** {
 576               	.LM49:
 577               	.LFBB7:
 578               	/* prologue: function */
 579               	/* frame size = 0 */
 580               	/* stack size = 0 */
 581               	.L__stack_usage = 0
 150:../../../src/drivers/platform/micaZ/source/DS2401.c ****     SFIOR &= ~(1 << PUD);
 583               	.LM50:
 584 012c 80B5      		in r24,64-32
 585 012e 8B7F      		andi r24,lo8(-5)
 586 0130 80BD      		out 64-32,r24
 151:../../../src/drivers/platform/micaZ/source/DS2401.c ****     DataPin_PullUp;
 588               	.LM51:
 589 0132 D498      		cbi 58-32,4
 590 0134 DC9A      		sbi 59-32,4
 591               	.LBB48:
 592               	.LBB49:
 594               	.Ltext23:
 596               	.LM52:
 597 0136 86EF      		 ldi r24,lo8(-10)
 598 0138 8A95      	    1:dec r24
 599 013a 01F4      	    brne 1b
 600               	/* epilogue start */
 601               	.LBE49:
 602               	.LBE48:
 604               	.Ltext24:
 152:../../../src/drivers/platform/micaZ/source/DS2401.c ****     _delay_us(100);   // One time slot for powerup
 153:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 606               	.LM53:
 607 013c 0895      		ret
 609               	.Lscope7:
 611               		.stabd	78,0,0
 614               	.global	DS2401_getSerialNumber
 616               	DS2401_getSerialNumber:
 617               		.stabd	46,0,0
 154:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 155:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 156:../../../src/drivers/platform/micaZ/source/DS2401.c **** // Reads the 32 bit world wide unique serial number
 157:../../../src/drivers/platform/micaZ/source/DS2401.c **** // valid is set to 0 in case of success, -2 in case of family code mismatch, -1 in case of CRC erro
 158:../../../src/drivers/platform/micaZ/source/DS2401.c **** inline uint32_t DS2401_getSerialNumber(int8_t *valid) {
 619               	.LM54:
 620               	.LFBB8:
 621 013e EF92      		push r14
 622 0140 FF92      		push r15
 623 0142 0F93      		push r16
 624 0144 1F93      		push r17
 625 0146 DF93      		push r29
 626 0148 CF93      		push r28
 627 014a 00D0      		rcall .
 628 014c 00D0      		rcall .
 629 014e CDB7      		in r28,__SP_L__
 630 0150 DEB7      		in r29,__SP_H__
 631               	/* prologue: function */
 632               	/* frame size = 4 */
 633               	/* stack size = 10 */
 634               	.L__stack_usage = 10
 635 0152 7C01      		movw r14,r24
 159:../../../src/drivers/platform/micaZ/source/DS2401.c ****     uint32_t serialNumber = 0;
 637               	.LM55:
 638 0154 1982      		std Y+1,__zero_reg__
 639 0156 1A82      		std Y+2,__zero_reg__
 640 0158 1B82      		std Y+3,__zero_reg__
 641 015a 1C82      		std Y+4,__zero_reg__
 160:../../../src/drivers/platform/micaZ/source/DS2401.c ****     uint8_t byte;
 161:../../../src/drivers/platform/micaZ/source/DS2401.c ****     signed char returnVal;
 162:../../../src/drivers/platform/micaZ/source/DS2401.c ****     returnVal = Maxim_1Wire_ResetPulse();
 643               	.LM56:
 644 015c 0E94 0000 		call Maxim_1Wire_ResetPulse
 163:../../../src/drivers/platform/micaZ/source/DS2401.c ****     if (returnVal != 0) return returnVal;
 646               	.LM57:
 647 0160 8823      		tst r24
 648 0162 01F0      		breq .L23
 650               	.LM58:
 651 0164 282F      		mov r18,r24
 652 0166 3327      		clr r19
 653 0168 27FD      		sbrc r18,7
 654 016a 3095      		com r19
 655 016c 432F      		mov r20,r19
 656 016e 532F      		mov r21,r19
 657 0170 00C0      		rjmp .L24
 658               	.L23:
 164:../../../src/drivers/platform/micaZ/source/DS2401.c ****     Maxim_1Wire_CommandReadRom();
 660               	.LM59:
 661 0172 0E94 0000 		call Maxim_1Wire_CommandReadRom
 165:../../../src/drivers/platform/micaZ/source/DS2401.c ****     if (Maxim_1Wire_ReadByte() != 0x01) *valid = -2;      //  Read device code
 663               	.LM60:
 664 0176 0E94 0000 		call Maxim_1Wire_ReadByte
 665 017a 8130      		cpi r24,lo8(1)
 666 017c 01F0      		breq .L25
 668               	.LM61:
 669 017e 8EEF      		ldi r24,lo8(-2)
 670 0180 F701      		movw r30,r14
 671 0182 8083      		st Z,r24
 672               	.L25:
 166:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 167:../../../src/drivers/platform/micaZ/source/DS2401.c ****     *(uint8_t*)&serialNumber = Maxim_1Wire_ReadByte();          //  Read ID Byte 0 - last significa
 674               	.LM62:
 675 0184 8E01      		movw r16,r28
 676 0186 0F5F      		subi r16,lo8(-(1))
 677 0188 1F4F      		sbci r17,hi8(-(1))
 678 018a 0E94 0000 		call Maxim_1Wire_ReadByte
 679 018e 8983      		std Y+1,r24
 168:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 169:../../../src/drivers/platform/micaZ/source/DS2401.c ****     *((uint8_t*)&serialNumber + 1) = Maxim_1Wire_ReadByte();    //  Read ID Byte 1
 681               	.LM63:
 682 0190 0E94 0000 		call Maxim_1Wire_ReadByte
 683 0194 F801      		movw r30,r16
 684 0196 8183      		std Z+1,r24
 170:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 171:../../../src/drivers/platform/micaZ/source/DS2401.c ****     *((uint8_t*)&serialNumber + 2) = Maxim_1Wire_ReadByte();    //  Read ID Byte 2
 686               	.LM64:
 687 0198 0E94 0000 		call Maxim_1Wire_ReadByte
 688 019c F801      		movw r30,r16
 689 019e 8283      		std Z+2,r24
 172:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 173:../../../src/drivers/platform/micaZ/source/DS2401.c ****     *((uint8_t*)&serialNumber + 3) = Maxim_1Wire_ReadByte();    //  Read ID Byte 3
 691               	.LM65:
 692 01a0 0E94 0000 		call Maxim_1Wire_ReadByte
 693 01a4 F801      		movw r30,r16
 694 01a6 8383      		std Z+3,r24
 174:../../../src/drivers/platform/micaZ/source/DS2401.c **** 
 175:../../../src/drivers/platform/micaZ/source/DS2401.c ****     Maxim_1Wire_ReadByte();                                     //  Read ID Byte 4 = 0
 696               	.LM66:
 697 01a8 0E94 0000 		call Maxim_1Wire_ReadByte
 176:../../../src/drivers/platform/micaZ/source/DS2401.c ****     Maxim_1Wire_ReadByte();                                     //  Read ID Byte 5 = 0 - most signi
 699               	.LM67:
 700 01ac 0E94 0000 		call Maxim_1Wire_ReadByte
 177:../../../src/drivers/platform/micaZ/source/DS2401.c ****     Maxim_1Wire_ReadByte();                                     //  Read CRC, tbd.
 702               	.LM68:
 703 01b0 0E94 0000 		call Maxim_1Wire_ReadByte
 178:../../../src/drivers/platform/micaZ/source/DS2401.c ****     *valid = 0;
 705               	.LM69:
 706 01b4 F701      		movw r30,r14
 707 01b6 1082      		st Z,__zero_reg__
 179:../../../src/drivers/platform/micaZ/source/DS2401.c ****     return serialNumber;
 709               	.LM70:
 710 01b8 2981      		ldd r18,Y+1
 711 01ba 3A81      		ldd r19,Y+2
 712 01bc 4B81      		ldd r20,Y+3
 713 01be 5C81      		ldd r21,Y+4
 714               	.L24:
 180:../../../src/drivers/platform/micaZ/source/DS2401.c **** }
 716               	.LM71:
 717 01c0 B901      		movw r22,r18
 718 01c2 CA01      		movw r24,r20
 719               	/* epilogue start */
 720 01c4 0F90      		pop __tmp_reg__
 721 01c6 0F90      		pop __tmp_reg__
 722 01c8 0F90      		pop __tmp_reg__
 723 01ca 0F90      		pop __tmp_reg__
 724 01cc CF91      		pop r28
 725 01ce DF91      		pop r29
 726 01d0 1F91      		pop r17
 727 01d2 0F91      		pop r16
 728 01d4 FF90      		pop r15
 729 01d6 EF90      		pop r14
 730 01d8 0895      		ret
 736               	.Lscope8:
 738               		.stabd	78,0,0
 739               		.comm _nrk_signal_list,4,1
 740               		.comm nrk_idle_task_stk,128,1
 741               		.comm nrk_kernel_stk_ptr,2,1
 746               	.Letext0:
 747               	.global __do_clear_bss
DEFINED SYMBOLS
                            *ABS*:00000000 DS2401.c
     /tmp/cc2kXn7Z.s:2      *ABS*:0000003f __SREG__
     /tmp/cc2kXn7Z.s:3      *ABS*:0000003e __SP_H__
     /tmp/cc2kXn7Z.s:4      *ABS*:0000003d __SP_L__
     /tmp/cc2kXn7Z.s:5      *ABS*:00000034 __CCP__
     /tmp/cc2kXn7Z.s:6      *ABS*:00000000 __tmp_reg__
     /tmp/cc2kXn7Z.s:7      *ABS*:00000001 __zero_reg__
     /tmp/cc2kXn7Z.s:136    .text:00000000 Maxim_1Wire_ResetPulse
     /tmp/cc2kXn7Z.s:256    .text:00000048 Maxim_1Wire_WriteBit
     /tmp/cc2kXn7Z.s:349    .text:0000007e Maxim_1Wire_ReadBit
     /tmp/cc2kXn7Z.s:435    .text:000000b2 Maxim_1Wire_WriteByte
     /tmp/cc2kXn7Z.s:493    .text:000000f0 Maxim_1Wire_ReadByte
     /tmp/cc2kXn7Z.s:549    .text:00000124 Maxim_1Wire_CommandReadRom
     /tmp/cc2kXn7Z.s:573    .text:0000012c DS2401_init
     /tmp/cc2kXn7Z.s:616    .text:0000013e DS2401_getSerialNumber
                            *COM*:00000004 _nrk_signal_list
                            *COM*:00000080 nrk_idle_task_stk
                            *COM*:00000002 nrk_kernel_stk_ptr

UNDEFINED SYMBOLS
__do_clear_bss
